# 9. 일관성과 합의

- 8장에서 봤듯이 분산 시스템에서는 많은 것들이 잘못될 수 있다. 쉬운 해결책으로 전체 서비스가 실패하도록 두고 사용자에게 오류 메시지를 보여주는 것..
- 이러한 해결책이 어렵다면 결함을 견더낼(tolerating) , 방법을 찾아함.
- 아래에서는 내결함설을 지닌 분산 시스템을 구축하는 데 쓰이는 알고리즘과 프로토콜의 몇 가지 예를 살펴 보자!

## 일관성 보장

- 복제 데이터 베이스는 대부분 최소한 최종적 일관성을 제공함.
  - 데이터베이스에 쓰기를 멈추고 볼 특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환한다는 뜻..
  - 모든 복제본이 결국 같은 값으로 수렴되기를 기대함으로 최종적 일관성보다 수렴이 더 나은 이름일 수도 있다..
  - 다만 위는 매우 약한 보장이며, 언제 복제본이 수렴될지에 대해서는 이야기가 없다.
  - 약한 보장만 제공하는 데이터베이스를 다룰 때는 그 제한을 알아야하고 뜻하지 않게 너무 많은 것을 가정하면 안된다.
- 아래에서는 데이터 시스템이 선택적으로 제공할 수 있는 더욱 강한 일관성 모델을 살펴보자!
  - 공통적으로 사용되는 가장 강한 일관성 모델 중 하나인 선현성(linearizability)을 살펴보고 장점과 단점을 검토한다.
  - 분산 시스템에서 이벤트 순서화 문제, 특히 인과성과 전체 순서화와 관련된 문제를 검토한다.
  - 분산 트랜잭션을 원자적으로 커밋하는 방법을 알아본다.

## 선형성

- 최종적 일관성을 지닌 데이터베이스에서 두 개의 다른 복제본에 같은 질문을 동시에 하면 두가지 다른 응답을 받을 수도 있음.
- 위 문제에서 데이터베이스가 복제본이 하나만 있다면, 더 단순해지지 않을까? 란 생각이 선형성을 뒷받침 해주는 아이디어다!
- 선형성은 원자적 일관성(atomic consistency), 강한 일관성(strong consistency), 즉각 일관성(immediate consistency), 외부 일관성(external consistency) 라고 함.
  - 기본적인 아이디어는 시스템에 데이터 복사본이 하나만 있고, 그 데이터를 대상으로 수행하는 모든 연산은 원자적으로 보이게 만드는 것임!
- 선형성 시스템에서는 클라이언트가 쓰기를 성공적으로 완료하자마자 그 데이터베이스를 읽는 모든 클라이언트는 방금 쓰여진 값을 볼 수 있어야 한다..

  - 즉 선형성은 최신성 보장(recency gurantee) 를 의미함.

  ### 시스템에 선형성을 부여하는 것은 무엇인가?

  - 선형성을 받침하는 기본 아이디어는 시스템에 데이터 복사본이 하나 뿐인 것 처럼 보이게 만드는것.
  - 선현성 데이터베이스에서 동시에 같은 키 x를 읽고 쓰는 세 클라이언트는 분산 시스템에 분야에서는 x를 레지스터(register) 라고 부름.

이미지 1

- 이 예제에서는 레지스터는 두 가지 종류의 연산이 있음.
  - read(x) => v 는 클라이언트가 레지스터 읽기를 요청하고 데이터베이스가 값 v를 반환했다는 것을 의미.
  - write(x, v) => r 은 클라이언트가 레지스터 x의 값을 v로 설정하라고 요청했고 데이터베이스가 응답 r을 반환했다는 것을 의미.
- 읽기 연산이 처리되는 시점에 쓰기의 영향이 발생했는지 알 수 없으므로, 쓰기와 읽기 연산은 동시에 실행함.

이미지 2

- 이를 해결하기 위해서는 다른 제약 조건을 추가해야함.
- 이를 좀 더 개선한 경우 -> (읽기와 쓰기 외에 세 번째 종류의 연산을 추가합니다.)

이미지 3

- Client B의 마지막 읽기는 선형적이지 않음.
- 이러한 방법을 통해서 모든 요청과 응답 시점을 유효한 순차 순서로 배열되는지 확인함으로써 시스템의 동작이 선형적인지 테스트 가능함.

* 선형성 대 직렬성

  - 직렬성
    - 직렬성은 모든 트랜잭션이 여러 객체를 읽고 쓸 수 있는 상황에서의 트랜잭션들의 격리 속성.
    - 직렬성은 트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장.
  - 선형성
    - 선형성은 레지스터(개별 객체)에 실행되는 읽기와 쓰기에 대한 최신성 보장임.
    - 선형성은 연산을 트랜잭션으로 묶지 않아서 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못함..

  데이터베이스는 직렬성과 선형성을 모두 제공할 수 있으므로 이러한 조합은 엄격한 직렬성(strict serializability) 혹은 강한 단일 복사 직렬성(strong one-copy serializability) 라고 함.

  그러나 직렬성 스냅숏 격리는 선형적이지 않고, 설계상 직렬성 스냅숏 격리는 읽는 쪽과 쓰는 쪽 사이의 잠금 경쟁을 피하기 위해 일관된 스냅숏에서 읽음. 일관된 스냅숏의 요점은 스냅숏에 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 것이고 따라서 스냅숏 읽기는 선형적이지 않다!

## 선형성에 기대기

### 잠금과 리더 선출

- 단일 리더 복제를 사용하는 시스템은 리더가 여러개가 아니라 진짜 하나만 보장해야함.
- 분산 잠금과 리더 선출을 구현하기 위해 아파치 주키퍼 나 etcd 같은 코디네이션 서비스가 사용됌.
- 분산 잠금은 오라클 리얼 애플리케이슨 클러스터 같은 분산 데이터베이스에서 훨씬 세분화된 수준으로 사용!

### 제약 조건과 유일성 보장

- 유일성 제약 조건은 데이터베이스에 흔함.
  - 이러한 조건을 강제하기 위해서는 선형성이 필요..
- 실제 애플리케이션에서는 종종 이런 제약 조건을 느슨하게 다르기도 하지만, 관계형 데이터베이스에서 전형적으로 볼 수 있는 엄격한 유일성 제약 조건은 선현성이 필요함!

### 채널간 타이밍 의존성

- 파일 저장 서비스가 선형적이면 잘 돌아가지만, 아니라면 경쟁 조건의 위험이 언제나 있음.
- 선형성이 경쟁 조건을 회피하는 유일한 방법은 아니지만 이해하기에는 가장 단순

## 선형성 시스템 구축하기

### 선형성과 정족수

- 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것처럼 보인다. 그러나 네트워크 지연의 변동이 심하면 경쟁 조건이 생길 수 있음.
- 정족수 조건이 만족됨에도 실행은 선형적이지 않을 수 있음.
- 성능이 떨어지는 비용을 지불하고 다이타모 스타일 정족수를 선형적으로 만드는 것도 가능하지만 이경우는 선형성 읽기와 쓰기 연산만 수행할 수 있음.
  - 즉, 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는 게 안전!

### CAP 정리

- 어플리케이션에서 선형성을 요구하고 네트워크 문제 때문에 일부 복제 서버가 다른 복제 서버와 연결이 끊기면 일부 복제 서버는 연결이 끊긴 동안은 요청을 처리할 수 없음, 네트워크 문제가 고쳐질때까지 기다리거나 오류를 반환해야함.( 즉 가용성이 없음!)
- 어플리케이션에서 선형성을 요구하지 않는다면 각 복제 서버가 다른 복제 서버와 연결이 끊기더라도 독립적으로 요청을 처리 하는 방식은 쓰기를 처리할 수 있음.
  이 경우 어플리케이션은 네트워크 문제에 직면해도 가용한 상태를 유지하지만 그 동작은 선형적이지 않음.

- 선형성이 필요 없는 어플리케이션은 네트워크 문제에 더 강인함.
  - 이를 **cap** 라고 함!
- CAP 는 데이터베이스에서 트레이드오프에 대한 논의를 시작하려는 목적으로 정의 없이 경험 법칙으로 제안됨.
- 공식적으로 정의된 CAP 정리는 매우 범위가 좁으며, 오직 하나의 일관성 모델과 한 종류의 결함만 고려함.

## 순서화 보장

선형성 레지스터는 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 어느 시점에서 원자적으로 효과가 나타나는 것처럼 보이며 이를 순서화라 표현!

- 단일 리더 복제에서 리더의 주 목적은 복제 로그에서 쓰기의 순서를 결정하는 것.
- 직렬성은 트랜잭션들이 어떤 일련 순서에 따라 실행되는 것처럼 동작하도록 보장하는 것과 관련되어 있음.
- 분산 시스템에서 타임 스탬프와 시계 사용은 무질서한 세상에서 질의를 부여하는 또 다른 시도임.

순서화, 선형성, 합의 사이에서는 깊은 연결 관계가 있음..

## 순서화와 인과성

순서화는 인과성을 보존하는데 도움을 준다!

- 일관된 순서로 읽기에서 대화의 관찰자가 질문에 대한 응답을 먼저 보고 나서 응답된 질문을 보게되는 예를, 질문과 답변 사이에 인과적 의존성(casual dependency)가 있다고 말합니다.
- 동시 쓰기 감지에서 두 개의 연산 A와 B가 있으면 세 가지 가능성이 있을 수 있습니다. A가 B보다 먼저, 같이 이후에 실행되는 경우가 있는데 이처럼 이전 발생(happened before) 관계는 인과성을 표현하는 또 다른 방법입니다.
- 트랜잭션을 스냅숏 격리의 맥락에서 트랜잭션은 일관된 스냅숏으로부터 읽는다고 말하는데 이때 일관적이란 인과성에 일관적(consistent with casuality) 라는 의미임.

### 인과적 순서가 전체 순서는 아니다.

- 전체 순서는 어떤 두 요소를 비교할 수 있게 하므로 두 요소가 있으면 항상 어떤 것이 더 크고 어떤것이 더 작은지 말할 수 있음.
- 수학적 집합은 이와 달리 비교불가 하고 , 부분적으로 순서가 정해짐.
- 전체 순서와 부분 순서의 차이점은 다른 데이터베이스 일관성 모델에 반영됨.
  - 선형성 -> 선형성 시스템에서는 연산의 전체 순서를 정할 수 있음.
  - 인과성 -> 두 연산 중 다른 것 보다, 먼저 실행 되지 않았다면, 두 연산이 동시적이라고 말함. 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 말임.
- 이러한 정의를 통해서 선형성 데이터스토어는 동시적 연산이 없으며, 하나의 타임라인이 있고 모든 연산은 그 타임라인을 따라서 전체 순서가 정해짐.
- 동시성은 타임라인이 갈라졌다 다시 합쳐지는 것을 의미..
- 깃과 같은 분산 버전 관리 시스템에 익숙하다면, 깃의 버전 히스토리는 인과적 의존성 그래프와 매우 유사함!

### 선형성은 인과적 일관성보다 강하다.

- 선형성은 인과성을 내포한다.
- 선형성은 인과성을 보장해준다는 사실은 이해하기도 쉽고 매력적으로 보일수 있지만, 이는 네트워크 지연에 따라 성능과 가용성에 해가 될 수 있음.
- 다만 절충선으로 선형적으로 만들지 않고도 인과적 일관성을 만족 시킬 수 있음.
- 대부분의 시스템에서 실제로 필요한 것은 선형성이 아닌 인과성임.

### 인과적 의존성 담기

- 인과성을 유지하기 위해서는 어떤 연산이 어떤 다른 연산보다 먼저 실행됐는지 알아야 한다.
- 인과적 의존성을 결정하려면 시스템에 있는 노드에 관한 "지식"을 기술할 방법이 필요!
- 앞에서는 리더 없는 데이터스토어는 갱신 손실 방지를 위해 같은 키에 대한 동시 쓰기를 검출해야하며, 인과적 의존성은 여기서 더 나아가서 버전 벡터를 일반화 할 수 있음.

## 일련번호 순서화

- 인과성은 중요한 이론적 개념이지만 모든 인과적 의존성을 추적하는 것은 실용성이 떨어짐.
- 더 좋은 방법은 일련번호와 타임스탬프를 써서 이벤트의 순서를 정함.
- 이러한 일련번호와 타임스탬프는 크기가 작고 전체 순서를 제공..
- 특히 인과성에 일관적인 전체 순서대로 일련번호를 생성 할 수 있음.
  - 연산 A가 연산 B보다 인과적으로 먼저 실행되었다면, A는 전체 순서에서도 B보다 먼저이다.
- 단일 리더 복제를 쓰는 데이터베이스에서는 복제 로그가 인과성에 일관적인 쓰기 연산의 전체 순서를 정의한다.
  - 리더는 연산마다 카운터를 증가시키고 복제 로그의 연산에 단조 증가하는 일련번호를 할당하기만 하면 됌.

### 비인과적 일련번호 생성기

- 단일 리더가 없다면 연산에 사용할 일련번호를 생성하는 방법이 명확해 보이지 않지만, 다양한 방법이 사용됨.
  - 각 노드가 자신만의 독립적인 일련번호 집합을 생성할 수 있음.
  - 각 연산에 일 기준 시계에서 얻은 타임스탬프를 붙일 수 있음.
  - 일련번호 블록을 미리 할당 할 수 있음.
- 위의 세가지 선택지는 모두 잘 동작하며, 카운터를 증가시키는 단일 리더에 모든 연산을 밀어넣는 것 보다 확장성이 좋으나, 생성된 일련번호가 인과성에 일관적이지 않음..

### 램포트 타임스탬프

- 이러한 방법 대신 인과성에 일관적인 일련번호를 생성하는 간단한 방법이 있으며, 이를 램포트 타임스탬프라고 부른다.
- 램포트 타임스탬프는 (카운터 , 노드ID) 의 쌍임..
- 두 노드는 떄때로 카운터 값이 같을 수 있지만, 타임스탬프에 노드 ID를 포함시켜서 각 타임스탬프는 유일하게 된다!

- 램포트 타임스탬프는 물리적 일 기준 시계와 아무런 관련이 없으나 전체 순서화를 제공.
  - 두 타임스탬프가 있으면 카운터가 큰 것이 타임스탬프가 크며, 카운터 값이 같으면 노드 ID 가 큰 것이 타임 스탬프가 크다.
- 핵심 아이디어는 모든 노드와 모든 클라이언트가 본 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최댓값을 포함함.
- 램포트 타임스탬프는 버전 벡터와 혼동될 수 있지만 목적이 다름.
  - 버전 벡터는 두 연산이 동시적인지 또는 어떤 연산에 인과적으로 의존하는지 구별 할 수 있지만, 램포트 타임스탬프는 항상 전체 순서화를 강제함.

### 타임스탬프 순서화로는 충분하지 않다.

- 램포트 타임스탬프가 인과성에 일관적인 연산의 전체 순서를 정의하지만 분산 시스템의 공통 문제를 해결하는 데 아주 충분하지 않음.
- 램포트 타임스탬프는 사후에 성공하는 쪽을 결정하는 데는 효과적이나 시스템에서 사용자명 생성 연산을 모두 모으면 그들의 타임스태프를 비교할 수 있다.
- 그러나 노드가 사용자로부터 사용자명 생성 요청을 막 받고 그 요청이 성공해야 하는지 실패해야 하는지 당장 결정해야 할 때는 이 방법으로는 역부족.
- 다른 어떤 노드도 동시에 더 낮은 타임스탬프를 가지고 동일한 사용자명으로 계정 생성을 처리하는 중이 아니라고 확신하려면 다른 노드가 무엇을 하고 있는지 확인해야 하며, 다른 노드 중 하나에 장애가 생기거나 네트워크 문제 때문에 연결할 수 없다면 시스템이 장애가 생김.
  - 즉, 연산의 전체 순서는 모든 연산은 모은 후에야 드러납니다
- 결론적으로, 사용자명에 대해 유일성 제약 조건 같은 것을 구현하려면 연산의 전체 순서가 있는 것으로는 충분하지 않아서, 이를 해결하는 아이디어로 전체 순서 브로드캐스트가 등장!

https://azderica.github.io/til/docs/data/designing-data-intensive-applications/ch9/
